package main

import (
	"context"
	_ "embed"
	"flag"
	"fmt"
	"log"

	"github.com/orsinium-labs/wypes"
	"github.com/tetratelabs/wazero"
	"gocv.io/x/gocv"
)

// processFrameWasm was generated by the following:
//
//	cd modules/processor; tinygo build -o ../processor.wasm -target=wasm-unknown .
//
//go:embed modules/processor.wasm
var processFrameWasm []byte

func main() {
	// Parse positional arguments.
	flag.Parse()

	// Choose the context to use for function calls.
	ctx := context.Background()

	// Create a new WebAssembly Runtime.
	r := wazero.NewRuntime(ctx)
	defer r.Close(ctx) // This closes everything this Runtime created.

	println("Defining host function...")
	modules := wypes.Modules{
		"hosted": wypes.Module{
			"pong": wypes.H0(pongFunc),
		},
	}

	err := modules.DefineWazero(r, nil)
	if err != nil {
		fmt.Printf("error define host functions: %v", err)
		return
	}

	// Instantiate the guest Wasm into the same runtime. It exports the `add`
	// function, implemented in WebAssembly.
	mod, err := r.Instantiate(ctx, processFrameWasm)
	if err != nil {
		log.Panicf("failed to instantiate module: %v", err)
	}
	ping := mod.ExportedFunction("ping")

	// Open the webcam.
	deviceID := "/dev/video0"
	webcam, err := gocv.OpenVideoCapture(deviceID)
	if err != nil {
		fmt.Printf("Error opening video capture device: %v\n", deviceID)
		return
	}
	defer webcam.Close()

	// streaming, capture from webcam
	buf := gocv.NewMat()
	defer buf.Close()

	fmt.Printf("Start reading device: %v\n", deviceID)
	i := 0
	for {
		if ok := webcam.Read(&buf); !ok {
			fmt.Printf("frame error %v\n", deviceID)
			continue
		}
		if buf.Empty() {
			continue
		}

		i++
		fmt.Printf("Read frame %d\n", i+1)
		_, err := ping.Call(ctx)
		if err != nil {
			fmt.Printf("Error calling ping: %v\n", err)
		}
	}
}

func pongFunc() wypes.Void {
	println("pong")
	return wypes.Void{}
}
