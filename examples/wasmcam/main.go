package main

import (
	"context"
	_ "embed"
	"flag"
	"fmt"
	"log"

	"github.com/subeshb1/wasm-go-image-to-ascii/convert"

	"github.com/orsinium-labs/wypes"
	"github.com/tetratelabs/wazero"
	"gocv.io/x/gocv"
)

const (
	// FixedWidth is the fixed width of the ASCII image
	FixedWidth = 80

	// FixedHeight is the fixed height of the ASCII image
	FixedHeight = 60
)

// processFrameWasm was generated by the following:
//
//	cd modules/processor; tinygo build -o ../processor.wasm -target=wasm-unknown .
//
//go:embed modules/processor.wasm
var processFrameWasm []byte

func main() {
	flag.Parse()

	ctx := context.Background()
	r := wazero.NewRuntime(ctx)
	defer r.Close(ctx)

	println("Defining host function...")
	modules := wypes.Modules{
		"hosted": wypes.Module{
			"println":  wypes.H1(hostPrintln),
			"complete": wypes.H0(completeFunc),
		},
		"wasm:cv/mat": wypes.Module{
			"[method]mat.cols": wypes.H1(matColsFunc),
			"[method]mat.rows": wypes.H1(matRowsFunc),
			"[method]mat.type": wypes.H1(matTypeFunc),
		},
		"wasm:cv/cv": wypes.Module{
			"gaussian-blur": wypes.H6(matGaussianBlurFunc),
		},
	}

	err := modules.DefineWazero(r, nil)
	if err != nil {
		fmt.Printf("error define host functions: %v", err)
		return
	}

	mod, err := r.Instantiate(ctx, processFrameWasm)
	if err != nil {
		log.Panicf("failed to instantiate module: %v", err)
	}
	process := mod.ExportedFunction("process")

	// Open the webcam.
	deviceID := "/dev/video0"
	webcam, err := gocv.OpenVideoCapture(deviceID)
	if err != nil {
		fmt.Printf("Error opening video capture device: %v\n", deviceID)
		return
	}
	defer webcam.Close()

	// streaming, capture from webcam
	frame = gocv.NewMat()
	defer frame.Close()

	processed = gocv.NewMat()
	defer processed.Close()

	asciiConverter := convert.NewImageConverter()
	opts := &convert.Options{FixedWidth: FixedWidth, FixedHeight: FixedHeight, Colored: true}

	fmt.Printf("Start reading device: %v\n", deviceID)
	i := 0
	for {
		if ok := webcam.Read(&frame); !ok {
			fmt.Printf("frame error %v\n", deviceID)
			continue
		}
		if frame.Empty() {
			continue
		}

		// clear screen
		fmt.Print("\033[H\033[2J")

		i++
		fmt.Printf("Read frame %d\n", i+1)
		_, err := process.Call(ctx, 0)
		if err != nil {
			fmt.Printf("Error calling process: %v\n", err)
		}

		img, err := processed.ToImage()
		if err != nil {
			fmt.Printf("Error converting mat to image: %v\n", err)
			continue
		}

		// print the ASCII representation of the frame
		fmt.Println(asciiConverter.Image2ASCIIString(img, opts))
	}
}

func completeFunc() wypes.Void {
	println("Frame complete\n")
	return wypes.Void{}
}

func hostPrintln(msg wypes.String) wypes.Void {
	println(msg.Unwrap())
	return wypes.Void{}
}
